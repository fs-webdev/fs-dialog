<link rel="import" href="../fs-core-element/fs-core-element.html">
<link rel="import" href="../a11y-enhancer/dialog.html">
<link rel="import" href="../inert/inert.html">

<style>
/*
 * 1. The display property cannot be animated so we need to use opacity and visibility
 *    to fade in
 *    @see https://stackoverflow.com/questions/3331353/transitions-on-the-display-property
 * 2. Delay the visibility property so we can see the dialog disappear
 *    @see https://codepen.io/matthewlein/pen/fvrLD
 * 3. Support a fixed modal header/footer and scrollable middle
 * 4. Temporary hack until fs-styles removes background image from fs-dialog__close
 * 5. Safari's default active button color seems to be white (activebuttontext)
 */
fs-dialog {
  background: #fff;
  border-radius: 4px;
  border-radius: var(--fs-border-radius, 4px);
  box-shadow: 0px 0px 4px 0px rgba(0,0,0,0.35), 0px 3px 2px 0px rgba(0,0,0,0.18);
  display: flex; /* [3] */
  flex-direction: column;
  max-height: 100vh;
  max-width: 545px;
  opacity: 0;
  position: fixed;
  transition: opacity 0.3s, visibility 0s linear 0.3s; /* [2] */
  visibility: hidden;
  width: 100%;
}

fs-dialog:not([type="modeless"]) {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%) scale(0.7);
  transition: opacity 0.3s, visibility 0s linear 0.3s, transform 0.3s; /* [2] */
}

/* [1] */
fs-dialog[open],
.fs-dialog__mask[open] {
  opacity: 1;
  transition: opacity 0.3s, visibility 0s linear;
  visibility: visible;
}

fs-dialog[open]:not([type="modeless"]) {
  transform: translate(-50%, -50%) scale(1);
  transition: opacity 0.3s, visibility 0s linear, transform 0.3s;
}

.fs-dialog__mask {
  background: rgba(51,51,49,0.8);
  bottom: 0;
  left: 0;
  opacity: 0;
  position: fixed;
  right: 0;
  top: 0;
  transition: opacity 0.3s, visibility 0s linear 0.3s; /* [2] */
  visibility: hidden;
}

fs-dialog header {
  border-bottom: 1px solid #ccc;
  border-bottom: 1px solid var(--fs-color-grey-border, #ccc);
  border-radius: 4px 4px 0 0;
  border-radius: var(--fs-border-radius, 4px) var(--fs-border-radius, 4px) 0 0;
  flex-shrink: 0;
  padding: 15px 15px 10px;
}

/* [4] */
fs-dialog .fs-dialog__close {
  background-image: none !important;
  color: inherit; /* [5] */
  top: 15px;
  opacity: 1;
}

fs-dialog .fs-dialog__close:active svg {
  width: 11px;
  height: 11px;
}

.fs-dialog__body {
  flex-grow: 1;
  overflow-y: auto;
  padding: 15px;
  position: relative;
}

fs-dialog footer {
  background: #f4f4f4;
  background: var(--fs-color-grey-background-light, #f4f4f4);
  border-radius: 0 0 4px 4px;
  border-radius: 0 0 var(--fs-border-radius, 4px) var(--fs-border-radius, 4px);
  border-top: 1px solid #ccc;
  border-top: 1px solid var(--fs-color-grey-border, #ccc);
  flex-shrink: 0;
  padding: 10px 15px;
}





/** MODELESS **/
fs-dialog[type="modeless"] {
  left: 0;
  position: fixed;
  top: 0;
  transform: translate3d(0px, 0px, 0);
}

fs-dialog[type="modeless"] header {
  cursor: move;
}

.fs-dialog--dragging {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  cursor: move;
}




/** FROM-BOTTOM **/
fs-dialog[transition="from-bottom"]:not([type="modeless"]) {
  top: 100%;
  transform: translateX(-50%);
  transition: top 0.3s;
}

fs-dialog[transition="from-bottom"][open]:not([type="modeless"]) {
  top: 50%;
  transform: translate(-50%, -50%);
}





/** FROM-RIGHT **/
fs-dialog[transition="from-right"]:not([type="modeless"]) {
  left: 100%;
  transform: translateY(-50%);
  transition: left 0.3s;
}

fs-dialog[transition="from-right"][open]:not([type="modeless"]) {
  left: 50%;
  transform: translate(-50%, -50%);
}
</style>

<!-- 1. Since we're not using shadow DOM and can't use <slot> elements, we can only
        add siblings to the user nodes and cannot move their nodes (breaks binding
        for polymer and angular)
     2. Use inline svg so the color can be changed with the rest of the text inside
        the header -->
<template id="fs-dialog-template">

  <button class="fs-dialog__close" data-dialog-dismiss>
    <svg aria-hidden="true" width='13' height='13' viewbox="0 0 13 13" preserveAspectRatio="xMidYMin"><g transform='translate(-1.000000, -1.000000)'><path d='M13 2L2 13M2 2L13 13' stroke='currentColor' stroke-width='2.5'/></g></svg>
  </button>

</template>

<script>
(function() {
  var doc = (document._currentScript || document.currentScript).ownerDocument;
  var template = doc.querySelector('#fs-dialog-template');
  var fsCore = document.createElement('fs-core-element');
  fsCore.translations = /* LANG CODE */;

  var zIndex = 990;
  var zIndexIncrement = 10;

  var numModalsOpen = 0;  // keep track of how many modals are open to speed up work

  var proto = Object.create(HTMLElement.prototype);

  /**
   * Initialize the dialog and add events and accessibility features.
   */
  proto.createdCallback = function () {
    var clone = document.importNode(template.content, true);

    // selectors
    var closeEl = clone.querySelector('.fs-dialog__close');
    var bodyEl = this.querySelector('.fs-dialog__body');
    var headerEl = this.querySelector('header');
    var footerEl = this.querySelector('footer');

    // each modal dialog will get its own mask so when dialogs stack we can
    // know exactly which one to close
    var maskEl = document.createElement('div');
    maskEl.classList.add('fs-dialog__mask');

    // set aria-label on close button for screen readers
    closeEl.setAttribute('aria-label', fsCore.i18n('fs.shared.fsDialog.CLOSE'));

    // move the close button into the header or as the first child of the dialog
    // (so it's first in the tab order)
    if (headerEl) {
      headerEl.appendChild(closeEl);
    }
    else {
      this.insertBefore(closeEl, this.firstChild);
    }

    this.appendChild(clone);
    this.setAttribute('role', 'dialog');
    a11yEnhancer.dialog(this, null, {
      preventInert: [maskEl]
    });

    // can only check for type after a11yEnhancer has run
    if (this.type === 'modal') {

      // add mask as a previous sibling to the dialog so it's below it in z-index
      this.parentNode.insertBefore(maskEl, this);

      // bind the functions that will used in event listeners to avoid losing reference
      this._maskClickHandler = this.close.bind(this);

      // add role=main to body of a modal dialog to improve accessibility for screen
      // readers. can't just use the <main> element since modeless dialogs don't
      // hide any <main> elements on the page
      // @see https://web-a11y.slack.com/archives/C042TSFGN/p1499454746902809
      if (bodyEl) {
        bodyEl.setAttribute('role', 'main');
      }
    }
    else {

      // bind the functions that will used in event listeners to avoid losing reference
      this._startDragHandler = startDragHandler.bind(this);
      this._dragHandler = dragHandler.bind(this);
      this._endDragHandler = endDragHandler.bind(this);
    }




    // open the dialog (event fired from a11y-enhancer)
    this.addEventListener('dialog-opened', function(e) {
      this.setAttribute('open', '');

      // allow multiple dialogs to be open at a time by incrementing z-index by
      // the order they were opened
      zIndex += zIndexIncrement;
      this.style.zIndex = zIndex;

      this.addEventListener('click', dialogClickHandler);

      if (this.type === 'modal') {
        numModalsOpen++;

        maskEl.setAttribute('open', '');
        maskEl.style.zIndex = zIndex;

        maskEl.addEventListener('click', this._maskClickHandler);

        // if there is more than one dialog open on the page the inert attribute will
        // have been added to it's parent tree. we'll need to uninert the tree and
        // reinert any sibling subtrees
        // use setTimeout to give the a11yEnhancer inerting a chance to run, otherwise
        // removing inert from the mask doesn't work (it would seem the inert polyfill
        // is async)
        if (numModalsOpen > 1) {
          setTimeout(function() {
            this.inert = false;
            maskEl.inert = false;

            this._inerted = {
              parents: [],
              children: []
            };
            var el = this;

            do {

              // an element that is a child of a shadowroot will have a parentNode but not
              // a parentElement. a shadowroot element has neither but instead has a host
              var parent = el.parentNode || el.host;

              // only inert subtrees if an ancestor of the dialog is inerted
              if (parent.inert) {
                parent.inert = false;
                this._inerted.parents.push(parent);

                for (var i = 0, child; (child = parent.children[i]); i++) {

                  // by only adding inert to elements that have not been inerted, we can
                  // preserve a11y through stacking modals
                  if (child !== el && child !== maskEl && !child.inert) {
                    child.inert = true;
                    this._inerted.children.push(child);
                  }
                }
              }

              el = parent;
            } while (el !== document.body);
          }.bind(this), 100);
        }

        // when the body of the dialog scrolls we need to allow keyboard users to
        // focus the scrolling content so they can use the up/down arrow keys
        // to scroll
        // @see https://stackoverflow.com/questions/4814398/how-can-i-check-if-a-scrollbar-is-visible
        // @see https://github.com/angular/material/issues/2961
        // @see https://github.com/miguelcobain/ember-paper/pull/393
        if (bodyEl && bodyEl.scrollHeight > bodyEl.clientHeight) {
          bodyEl.setAttribute('tabindex', 0);
        }
      }
      else {

        // calc center of screen for initial modeless dialog transform property
        if (!this.style.transform) {
          var x = (window.innerWidth / 2) - (this.offsetWidth / 2);
          var y = (window.innerHeight / 2) - (this.offsetHeight / 2);
          this.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0)';
        }

        // add events to modeless dialog for dragging
        if (headerEl) {
          headerEl.addEventListener('mousedown', this._startDragHandler);
          headerEl.addEventListener('touchstart', this._startDragHandler);
          window.addEventListener('mouseup', this._endDragHandler);
          window.addEventListener('touchend', this._endDragHandler);
        }
      }

      this.dispatchEvent(new Event('fs-dialog-open', {bubbles: true}));
    }.bind(this));




    // close the dialog (event fired from a11y-enhancer)
    this.addEventListener('dialog-closed', function(e) {
      this.removeAttribute('open');

      // inert attribute doesn't have to be added back since visibility:hidden
      // elements are already removed from the DOM both visually and for screen
      // readers

      zIndex -= zIndexIncrement;

      this.removeEventListener('click', dialogClickHandler);

      if (this.type === 'modal') {

        // uninert all children nodes and reinert parent nodes. in Safari this
        // causes a visually delay in the closing animation so we need to delay it
        if (numModalsOpen > 1) {
          setTimeout(function() {
            this._inerted.children.forEach(function(node) {
              node.inert = false;
            });
            this._inerted.parents.forEach(function(node) {
              node.inert = true;
            });
            this._inerted = null;
          }.bind(this), 100);
        }

        numModalsOpen--;
        maskEl.removeAttribute('open');
        maskEl.removeEventListener('click', this._maskClickHandler);
      }
      else if (headerEl) {

        // clean up events to modeless dialog for dragging
        headerEl.removeEventListener('mousedown', this._startDragHandler);
        headerEl.removeEventListener('touchstart', this._startDragHandler);
        window.removeEventListener('mouseup', this._endDragHandler);
        window.removeEventListener('touchend', this._endDragHandler);
      }

      this.dispatchEvent(new Event('fs-dialog-close', {bubbles: true}));
    }.bind(this));

    // start opened (needs to be done after adding the event listeners to open
    // otherwise it wont run any of that code)
    if (this.hasAttribute('open')) {
      this.open();
    }
  };

  /**
   * Listen to the open attribute.
   */
  proto.attributeChangedCallback = function(attr, oldValue, newValue) {

    // open and close the modal with the `open` attribute
    if (attr === 'open') {
      if (newValue !== null) {
        this.open();
      }
      else {
        this.close();
      }
    }
  };

  /**
   * Determine when to close the dialog.
   */
  function dialogClickHandler(e) {

    // handle child elements of elements with these attributes
    var el = e.target;
    while (el !== this) {
      if (el.hasAttribute('data-dialog-dismiss')) {
        this.dispatchEvent(new Event('fs-dialog-dismiss', {bubbles: true}));

        // stop the event from propagating to parent fs-dialogs
        e.stopPropagation();
        this.close();
      }

      // confirming the dialog does not close it. allow the user to determine
      // what to do with the modal
      if (el.hasAttribute('data-dialog-confirm')) {
        this.dispatchEvent(new Event('fs-dialog-confirm', {bubbles: true}));

        // stop the event from propagating to parent fs-dialogs
        e.stopPropagation();
      }

      el = el.parentElement;
    }
  }

  /**
   * Set up dragging for the dialog.
   * @see http://jsfiddle.net/Lk2hLt
   * @see http://interactjs.io/
   */
  function startDragHandler(e) {

    // only activate drag with left mouse button
    if (e.type === 'mousedown' && e.button !== 0) return true;

    // normalize mousedown and touchstart x/y position
    var clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
    var clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;

    // store the current x/y position as well as the start x/y of the event
    // (getBoundingClientRect takes into account transform x/y)
    // @see https://stackoverflow.com/a/22360535/2124254
    var rect = this.getBoundingClientRect();
    this._drag = {
      xPos: rect.left,
      yPos: rect.top,
      clientX: clientX,
      clientY: clientY,

      // don't let the dialog go outside of the window
      maxX: window.innerWidth - this.offsetWidth,
      maxY: window.innerHeight - this.offsetHeight
    };

    window.addEventListener('mousemove', this._dragHandler, true);
    window.addEventListener('touchmove', this._dragHandler, true);
  }

  /**
   * Update the x/y position of the dialog while dragging.
   */
  function dragHandler(e) {
    e.preventDefault();
    e.stopPropagation();

    // prevent user highlighting while dragging by disabling user-select through css
    if (!this._drag.isDragging) {
      document.body.classList.add('fs-dialog--dragging');
      this._drag.isDragging = true;
    }

    // normalize mousedown and touchstart x and y position
    var clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
    var clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;

    var dx = clientX -this._drag.clientX;
    var dy = clientY - this._drag.clientY;

    var x = this._drag.xPos + dx;
    var y = this._drag.yPos + dy;

    // bind x/y to window
    if (x < 0) {
      x = 0;
    }
    else if (x > this._drag.maxX) {
      x = this._drag.maxX
    }

    if (y < 0) {
      y = 0;
    }
    else if (y > this._drag.maxY) {
      y = this._drag.maxY;
    }

    this.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0)';

    // update x/y position
    this._drag.clientX = clientX;
    this._drag.clientY = clientY;
    this._drag.xPos = x;
    this._drag.yPos = y;
  }

  /**
   * Clean up events and properties when drag is finished.
   */
  function endDragHandler() {
    document.body.classList.remove('fs-dialog--dragging');
    this._drag = null;

    window.removeEventListener('mousemove', this._dragHandler, true);
    window.removeEventListener('touchmove', this._dragHandler, true);
  }

  document.registerElement('fs-dialog', {prototype: proto});
})();
</script>