<!-- <script src="../webcomponentsjs/webcomponents-lite.js"></script> -->
<link rel="import" href="../fs-globals/fs-globals.html">
<link rel="import" href="../fs-dialog/fs-dialog-base.html">
<script src="../fs-dialog/fs-dialog-positioning-obj.js"></script>

<style data-fs-anchored-dialog>

  fs-anchored-dialog {
    position: absolute;
  }

  fs-anchored-dialog .fs-dialog-pointer {
    border: 16px solid transparent;
    content: '';
    height: 0;
    overflow: visible;
    position: absolute;
    width: 0;
    /*box-shadow: 0px 0px 4px 0px rgba(0,0,0,0.35), 0px 3px 2px 0px rgba(0,0,0,0.18);*/
    /*background-color: #fff;
    height: 22.627px;
    width: 22.627px;
    transform: rotate(45deg);*/
  }
  fs-anchored-dialog[pointer-direction="up"] .fs-dialog-pointer {
    left: calc(50% - 16px);
    top: -16px;
    border-bottom-color: #FFF;
    border-top-width: 0;
  }
  fs-anchored-dialog[pointer-direction="down"] .fs-dialog-pointer {
    left: calc(50% - 16px);
    bottom: -16px;
    border-top-color: #FFF;
    border-bottom-width: 0;
  }
  fs-anchored-dialog[pointer-direction="left"] .fs-dialog-pointer {
    left: -16px;
    top: calc(50% - 16px);
    border-right-color: #FFF;
    border-left-width: 0;
  }
  fs-anchored-dialog[pointer-direction="right"] .fs-dialog-pointer {
    right: -16px;
    top: calc(50% - 16px);
    border-left-color: #FFF;
    border-right-width: 0;
  }
  fs-anchored-dialog[no-pointer] .fs-dialog-pointer {
    visibility: hidden;
    display: none;
  }

  @media screen and (max-width: 480px) {
    fs-anchored-dialog:not([fullscreen-on-mobile="false"]) .fs-dialog-pointer {
      visibility: hidden;
      display: none;
    }
  }

</style>

<template id="fs-anchored-dialog-template">
  <div class="fs-dialog-pointer"></div>
</template>

<script>
(function() {
  var doc = (document._currentScript || document.currentScript).ownerDocument;
  var template = doc.querySelector('#fs-anchored-dialog-template');
  var positioningObj = FS.dialog.service.positioningObj;

  var LEFT = 'left';
  var RIGHT = 'right';
  var UP = 'up';
  var DOWN = 'down';
  var CENTER = 'center';
  var BOTTOM = 'bottom';
  var TOP = 'top';
  var POINTER_DIRECTION = 'pointer-direction';
  var POINTER_BASE = 32;
  var POINTER_ALTITUDE = 16;
  var PADDING = 15;
  var positionObjDefaults = {
    preferredPointerDirection: ''
  };

  class FSAnchoredDialog extends FS.dialog.baseDialogComponent {

    connectedCallback() {
      this.attachedCallback();
    }
    /**
     * Initialize the popover, add events, and accessibility features. Should only change
     * the DOM on attached callback otherwise it breaks Polymer bindings.
     */
    attachedCallback() {
      this.appendStyles(doc, 'style[data-fs-anchored-dialog]', this);

      var clone = document.importNode(template.content, true);
      this.appendChild(clone);

      var doNotDismissOnBlur = this.getAttribute('persistent')
      if (doNotDismissOnBlur) {
        this.removeAttribute('dismiss-on-blur');
      } else {
        this.setAttribute('dismiss-on-blur', '');
      }

      this._resizeHandler = resizeHandler.bind(this);
      this._resizeThrottler = resizeThrottler.bind(this);

      super.attachedCallback(openAnchoredFunction, closeAnchoredFunction);

      var resizeTimeout;
      function resizeThrottler() {
        // ignore resize events as long as an resizeHandler execution is in the queue
        if ( !resizeTimeout ) {
          resizeTimeout = setTimeout(function() {
            resizeTimeout = null;
            this._resizeHandler();
            // The resizeHandler will execute at a rate of 15fps
          }.bind(this), 66);
        }
      }

      function resizeHandler(event) {
        var pointerElement = this.querySelector('.fs-dialog-pointer');
        var dialogElement = this;
        var sourceElement = this.attachToElement;
        var pointerDirection = this.getAttribute(POINTER_DIRECTION);
        var noPointer = this.getAttribute('no-pointer');

        // we put this in a setTimout so that the dom can update before we do our calculations
        setTimeout(function(){
          if (noPointer !== undefined && noPointer !== null) {
            positionDialogWithinDom(this, pointerElement, getPointerlessDialogRect.bind(this)({attachToElement: sourceElement}), {left: 0, top: 0}, '');
          } else {
            var newRects = getRectsWithForcedDirection.bind(this)(sourceElement, dialogElement, pointerElement, pointerDirection, true);
            positionDialogWithinDom(dialogElement, pointerElement, newRects.dialogRect, newRects.pointerRect, pointerDirection);
          }
        }.bind(this), 0)
      };

      function openAnchoredFunction(positionObj) {
        window.addEventListener('resize', this._resizeThrottler);
        positionObj = positionObj || {};

        if (this.getAttribute('persistent')) {
          this.removeAttribute('dismiss-on-blur');
        } else {
          this.setAttribute('dismiss-on-blur', '');
        }

        if (positionObj.attachToCoordinates && positionObj.attachToCoordinates.x && positionObj.attachToCoordinates.y) {
          var coordinateElement = this.coordinateElement;
          if (!coordinateElement) {
            coordinateElement = document.createElement('div');
            coordinateElement.id = 'coordinate-positioning-element';
            coordinateElement.style.position = 'absolute';
            document.body.appendChild(coordinateElement);
          }
          coordinateElement.style.left = positionObj.attachToCoordinates.x + 'px';
          coordinateElement.style.top = positionObj.attachToCoordinates.y + 'px';
          positionObj.attachToElement = coordinateElement;
        }

        positionObj.attachToElement = positionObj.attachToElement || document.activeElement;
        this.attachToElement = positionObj.attachToElement;
        /* positionObj: {
          preferredPointerDirection: [LEFT, RIGHT, UP, DOWN],
          forcedPointerDirection: LEFT, // only passed through in object
          preferredAttachDirection: [],
          attachDirection: BELOW, // attr (attach-direction) or passed through
          attachToElement: document.querySelector('button'), // REQUIRED
          noPointer: false, // only attr
          alignment: LEFT | RIGHT | CENTER | TOP | BOTTOM, // attr (alignment) or passed through
          attachToCoordinates: {x: 0, y: 0}, // global coordinates of where you want the dialog to attach to. This will behave as if there is an invisible element at this point, so the rest of the positioning/pointer direction logic remains the same
          TODO: closeOnScroll: false,
        } */
        // we get the last one in the array because that should be the one that belongs to this dialog in case there are nested popovers
        var pointerElement = this.querySelectorAll('.fs-dialog-pointer')[this.querySelectorAll('.fs-dialog-pointer').length - 1];
        // reset styles on elements
        pointerElement.style.top = '';
        pointerElement.style.left = '';
        this.style.top = '';
        this.style.left = '';

        var noPointer = this.getAttribute('no-pointer');

        // these will always be drop down type menus as far as the use cases we have currently go
        if (noPointer !== undefined && noPointer !== null) {
          positionDialogWithinDom(this, pointerElement, getPointerlessDialogRect.bind(this)(positionObj), {left: 0, top: 0}, '');
        } else if (positionObj.forcedPointerDirection) {
          var newRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, positionObj.forcedPointerDirection)
          positionDialogWithinDom(this, pointerElement, newRects.dialogRect, newRects.pointerRect, positionObj.forcedPointerDirection)
        } else {
          //auto-position
          var prefOrder = positionObj.preferredPointerDirection || [LEFT, RIGHT, UP, DOWN];
          var best = 0;
          var pos = prefOrder[0];
          var containingRect = positioningObj.fsGetWindowRect();
          var newRects;
          var leftRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, LEFT);
          var rightRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, RIGHT);
          var upRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, UP);
          var downRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, DOWN);

          var scores = {};
          scores.left = positioningObj.fsCalculatePercentageVisible(leftRects.dialogRect, containingRect);
          scores.right = positioningObj.fsCalculatePercentageVisible(rightRects.dialogRect, containingRect);
          scores.up = positioningObj.fsCalculatePercentageVisible(upRects.dialogRect, containingRect);
          scores.down = positioningObj.fsCalculatePercentageVisible(downRects.dialogRect, containingRect);

          prefOrder.every(function(tempPos) {
            if(best < scores[tempPos]) {
              pos = tempPos;
              best = scores[tempPos];
            }
            return true;
          });

          switch(pos) {
            case LEFT:
              newRects = leftRects;
              break;
            case RIGHT:
              newRects = rightRects;
              break;
            case UP:
              newRects = upRects;
              break;
            case DOWN:
              newRects = downRects;
              break;
          }
          positionDialogWithinDom(this, pointerElement, newRects.dialogRect, newRects.pointerRect, pos)
        }
      }

      function closeAnchoredFunction() {
        window.removeEventListener('resize', this._resizeThrottler);
        this.attachToElement = null;
        return;
      }

      function getPointerlessDialogRect(positionObj) {
        var attachToElementDirection = positionObj.attachDirection || this.getAttribute('attach-direction') || BOTTOM;
        var alignmentDirection = positionObj.alignment || this.getAttribute('alignment') || LEFT;
        var dialogElementOffsetParent = this.offsetParent || document.body;
        var srcRect = positioningObj.fsLocalToGlobal(positionObj.attachToElement);
        var dialogWidth = this.offsetWidth;
        var dialogHeight = this.offsetHeight;
        var topOffset = getTopOffset(dialogElementOffsetParent);
        var dialogTop, dialogLeft, dialogRect;

        // set the attrs on the element to match our alignment and attachDirections so we can access them on windowResize
        this.setAttribute('attach-direction', attachToElementDirection);
        this.setAttribute('alignment', alignmentDirection);


        switch(attachToElementDirection) {
          case BOTTOM:
          case TOP:
          default:
            switch (alignmentDirection) {
              case CENTER:
                dialogLeft = srcRect.left - dialogWidth/2 + srcRect.width/2;
                break;
              case RIGHT:
                dialogLeft = srcRect.left + srcRect.width - dialogWidth;
                break;
              case LEFT:
              default:
                dialogLeft = srcRect.left
                break;
            }
            break;
          case LEFT:
          case RIGHT:
            switch (alignmentDirection) {
              case CENTER:
                dialogTop = srcRect.top - dialogHeight/2 + srcRect.height/2 + topOffset;
                break;
              case TOP:
              default:
                dialogTop = srcRect.top + topOffset;
                break;
              case BOTTOM:
                dialogTop = srcRect.bottom + topOffset - dialogHeight;
                break;
            }
            break;
        }

        switch(attachToElementDirection) {
          case BOTTOM:
          default:
            dialogTop = srcRect.bottom + getTopOffset(dialogElementOffsetParent);
            break;
          case TOP:
            dialogTop = srcRect.top + getTopOffset(dialogElementOffsetParent) - dialogHeight;
            break;
          case LEFT:
            dialogLeft = srcRect.left - dialogWidth;
            break;
          case RIGHT:
            dialogLeft = srcRect.right;
            break;
        }

        dialogRect = new positioningObj.fsRect(dialogLeft, dialogTop, dialogWidth, dialogHeight)
        dialogRect = positioningObj.fsGlobalToLocal(dialogElementOffsetParent, dialogRect);
        return dialogRect;
      }

      function positionDialogWithinDom(dialogElement, pointerElement, newDialogRect, newPointerRect, direction) {
        // set the pointer-direction attribute
        dialogElement.setAttribute(POINTER_DIRECTION, direction);
        // position in the dom the dialog
        dialogElement.style.left = newDialogRect.left + 'px';
        dialogElement.style.top = newDialogRect.top + 'px';
        // position in the dom the pointer
        if (direction === LEFT || direction === RIGHT) {
          // the pointer element isn't relative to the dialog (its offset parent), it is realtive to the
          // dialog's offset parent. So, we have to subtract ou the dialog's top and left to get the top
          // and left of the pointer relative to the dialog.
          pointerElement.style.top = (newPointerRect.top - newDialogRect.top) + 'px';
        } else {
          pointerElement.style.left = (newPointerRect.left - newDialogRect.left) + 'px';
        }
      }

      function getRectsWithForcedDirection (sourceElement, dialogElement, pointerElement, direction, doNotAdjustForWindow) {

        var windowRect = positioningObj.fsGetWindowRect();
        var globalSrcRect = positioningObj.fsLocalToGlobal(sourceElement);
        var dialogElementOffsetParent = dialogElement.offsetParent || document.body;
        var srcRect = positioningObj.fsLocalToLocal(sourceElement, dialogElementOffsetParent);
        var pointerRect = positioningObj.fsLocalToLocal(pointerElement, dialogElementOffsetParent);
        var dialogRect = positioningObj.fsLocalToLocal(dialogElement, dialogElementOffsetParent);
        var dialogHeight = dialogElement.offsetHeight;
        var dialogWidth = dialogElement.offsetWidth;
        var topOffset = getTopOffset();

        // there's some weird stuff with positioning if the body is the dialog's offset parent
        if (dialogElementOffsetParent === document.body) {
          var bodyPosition = window.getComputedStyle(document.body).position
          var bodyRect = document.body.getBoundingClientRect();
          var leftOffset = bodyRect.left + window.pageXOffset;
          if (bodyPosition === 'static') {
            // sometimes the margins will mess up the getBoundingClientRect function on the
            // body, but if it's statically positioned, then we can just use the global rect
            srcRect = globalSrcRect;
            dialogRect = positioningObj.fsLocalToGlobal(dialogElement);
            // TODO: maybe you won't have to use the stupid topOffset on the pointerRect later if you globalize it here
            // for some reason the offset only applies on the left/right dialogs. Again, not sure why.
            if (direction === LEFT || direction === RIGHT) {
              srcRect.top = srcRect.top + topOffset;
              dialogRect.top = dialogRect.top + topOffset;
            // TODO: maybe you won't have to use the stupid topOffset on the pointerRect later if you globalize it here
            }
          } else {
            // the left for some reason doesn't always get calculated correctly if the body
            // is not positioned statically - this gives us the relative position
            srcRect.left = srcRect.left - leftOffset;
            dialogRect.left = dialogRect.left - leftOffset;
            // TODO: maybe you won't have to use the stupid topOffset on the pointerRect later if you globalize it here
          }
        }

        var srcHorizontalCenter = srcRect.left+(srcRect.width/2);
        var srcVerticalCenter = srcRect.top+(srcRect.height/2);
        var dialogTop = srcVerticalCenter-(dialogHeight/2);
        var dialogLeft = srcHorizontalCenter-(dialogWidth/2);
        var globalSrcHorizontalCenter = globalSrcRect.left+(globalSrcRect.width/2);
        var globalSrcVerticalCenter = globalSrcRect.top+(globalSrcRect.height/2);
        var globalDialogTop = globalSrcVerticalCenter-(dialogHeight/2);
        var globalDialogBottom = globalSrcVerticalCenter+(dialogHeight/2);
        var globalDialogRight = globalSrcHorizontalCenter+(dialogWidth/2);
        var globalDialogLeft = globalSrcHorizontalCenter-(dialogWidth/2);
        var xOffset = this.xOffset = calculateXOffset.bind(this)(doNotAdjustForWindow);
        var yOffset = this.yOffset = calculateYOffset.bind(this)(doNotAdjustForWindow);
        return positionDialog(xOffset, yOffset, pointerRect, srcRect, direction);

        function calculateXOffset(doNotAdjustForWindow) {
          var xOffset = 0;
          switch(direction){
            case UP:
            case DOWN:
              if (doNotAdjustForWindow) {
                return (dialogRect.width - POINTER_BASE)/2 - parseFloat(pointerElement.style.left.split('px')[0]);
                break;
              }
              if (globalDialogRight > windowRect.right) {
                xOffset = -(globalDialogRight - windowRect.right);
              } else if (globalDialogLeft < windowRect.left) {
                xOffset = Math.abs(globalDialogLeft) + windowRect.left;
              }
              break;
            case LEFT:
              xOffset += POINTER_ALTITUDE;
              break;
            case RIGHT:
              xOffset -= POINTER_ALTITUDE;
              xOffset -= srcRect.width;
              xOffset -= dialogWidth;
              break;
          }
          return xOffset;
        }

        function calculateYOffset(doNotAdjustForWindow) {
          var yOffset = 0;
          switch(direction) {
            case UP:
              yOffset += POINTER_ALTITUDE;
              break;
            case DOWN:
              yOffset -= POINTER_ALTITUDE;
              yOffset -= globalSrcRect.height;
              yOffset -= dialogHeight;
              break;
            case LEFT:
            case RIGHT:
              if (doNotAdjustForWindow) {
                return (dialogRect.height - POINTER_BASE)/2 - parseFloat(pointerElement.style.top.split('px')[0]);
                break;
              }
              if (globalDialogBottom > windowRect.bottom) {
                yOffset = -(globalDialogBottom - windowRect.bottom);
              } else if (globalDialogTop < windowRect.top) {
                yOffset = windowRect.top - globalDialogTop;

              }
              break;
          }
          return yOffset;
        }

        // TODO: rename
        function positionDialog(xOffset, yOffset, pointerRect, srcRect, direction) {
          var newDialogRectTop;
          var newDialogRectLeft;
          var newDialogRect;
          var newPointerRect = getNewPointerRect(pointerRect, srcRect, direction);
          switch(direction) {
            case UP:
            case DOWN:
              newDialogRectTop = srcRect.top+srcRect.height+yOffset;
              newDialogRectLeft = dialogLeft+xOffset;
              newDialogRect = new positioningObj.fsRect(newDialogRectLeft, newDialogRectTop, dialogWidth, dialogHeight);
              if (newDialogRect.left > newPointerRect.left - PADDING) {
                newDialogRect.left = newPointerRect.left - PADDING;
              } else if (newDialogRect.right < newPointerRect.right + PADDING) {
                newDialogRect.left = newDialogRect.left + (newPointerRect.right + PADDING - newDialogRect.right + PADDING);
              }
              break;
            case LEFT:
            case RIGHT:
              newDialogRectLeft = srcRect.left+srcRect.width+xOffset;
              newDialogRectTop = dialogTop+yOffset;
              newDialogRect = new positioningObj.fsRect(newDialogRectLeft, newDialogRectTop, dialogWidth, dialogHeight);
              if (newDialogRect.top > newPointerRect.top - PADDING) {
                newDialogRect.top = newPointerRect.top - PADDING;
              } else if (newDialogRect.bottom < newPointerRect.bottom + PADDING) {
                newDialogRect.top = newDialogRect.top + (newPointerRect.bottom + PADDING - newDialogRect.bottom);
              }
              break;
          }
          return {
            dialogRect: newDialogRect,
            pointerRect: newPointerRect
          }
        }
      };

      function getNewPointerRect(pointerRect, srcRect, direction) {
        var newPointerRectTop = pointerRect.top;
        var newPointerRectLeft = pointerRect.left;
        var newPointerRect;
        var pointerWidth;
        var pointerHeight;

        switch(direction) {
          case UP:
          case DOWN:
            newPointerRectLeft = srcRect.left + ((srcRect.width - POINTER_BASE)/2);
            pointerHeight = POINTER_ALTITUDE;
            pointerWidth = POINTER_BASE;
            break;
          case LEFT:
          case RIGHT:
            newPointerRectTop = srcRect.top+((srcRect.height - POINTER_BASE)/2) - getTopOffset();
            pointerHeight = POINTER_BASE;
            pointerWidth = POINTER_ALTITUDE;
            break;
        }
        return newPointerRect = new positioningObj.fsRect(newPointerRectLeft, newPointerRectTop, pointerWidth, pointerHeight);
      }

      function getTopOffset(dialogElementOffsetParent) {
        var topOffset = 0;
        if (dialogElementOffsetParent === document.body && window.getComputedStyle(document.body).position) {
          var bodyRect = document.body.getBoundingClientRect();
          topOffset = bodyRect.top + window.pageYOffset;
        }
        return topOffset;
      }

    }

    disconnectedCallback(){
      this.detachedCallback();
    }
    detachedCallback() {
      if (this.coordinateElement) {
        document.body.removeChild(this.coordinateElement);
        this.coordinateElement = null;
      }
    }
  }
  if('customElements' in window){
    customElements.define('fs-anchored-dialog', FSAnchoredDialog);
  } else {
    document.registerElement('fs-anchored-dialog', {prototype: Object.create(FSAnchoredDialog.prototype)});
  }
})();
</script>
