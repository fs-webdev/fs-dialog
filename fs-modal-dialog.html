<link rel="import" href="../fs-globals/fs-globals.html">
<link rel="import" href="../fs-dialog/fs-dialog-base.html">

<style data-fs-modal-dialog>
/*
 * 1. The display property cannot be animated so we need to use opacity and visibility
 *    to fade in
 *    @see https://stackoverflow.com/questions/3331353/transitions-on-the-display-property
 * 2. Delay the visibility property so we can see the dialog disappear
 *    @see https://codepen.io/matthewlein/pen/fvrLD
 * 3. Support a fixed modal header/footer and scrollable middle
 * 4. Temporary hack until fs-styles removes background image from fs-dialog__close
 * 5. Safari's default active button color seems to be white (activebuttontext)
 */

fs-modal-dialog {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%) scale(0.7);
  transition: opacity 0.3s, visibility 0s linear 0.3s, transform 0.3s; /* [2] */
}

fs-modal-dialog[opened] {
  transform: translate(-50%, -50%) scale(1);
  transition: opacity 0.3s, visibility 0s linear, transform 0.3s;
}

</style>

<script>
(function() {
  var doc = (document._currentScript || document.currentScript).ownerDocument;

  class FSModalDialog extends FS.dialog.baseDialogComponent {

    /**
     * Initialize the dialog, add events, and accessibility features. Should only change
     * the DOM on attached callback otherwise it breaks Polymer bindings.
     */
    attachedCallback() {
      this.appendStyles(doc, 'style[data-fs-modal-dialog]', this);

      // selectors
      var bodyEl = this.querySelector('.fs-dialog__body');
      var maskEl;

      // initialize
      this._a11yOpen = a11yOpen.bind(this);
      this._a11yClose = a11yClose.bind(this);
      this.setAttribute('aria-hidden', true);

      // use the attachedCallback for the base dialog and pass in our open and close functions
      super.attachedCallback(openModalFunction, closeModalFunction)


      // each modal dialog will get its own mask so when dialogs stack we can
      // know exactly which one to close
      maskEl = document.createElement('div');
      maskEl.setAttribute('data-no-inert', '');
      maskEl.setAttribute('tabindex', '-1');
      maskEl.classList.add('fs-dialog__mask');

      // add mask as a previous sibling to the dialog so it's below it in z-index
      this.parentNode.insertBefore(maskEl, this);

      // add role=main to body of a modal dialog to improve accessibility for screen
      // readers. can't just use the <main> element since modeless dialogs don't
      // hide any <main> elements on the page
      // @see https://web-a11y.slack.com/archives/C042TSFGN/p1499454746902809
      if (bodyEl) {
        bodyEl.setAttribute('role', 'main');
      }

      var keydownHandler = this.keydownHandler.bind(this);

      function openModalFunction() {
        this._a11yOpen();
        maskEl.addEventListener('keydown', keydownHandler);
        maskEl.setAttribute('opened', '');
        maskEl.style.zIndex = this.style.zIndex;
      }

      function closeModalFunction() {
        this._a11yClose();
        maskEl.removeAttribute('opened');
        maskEl.removeEventListener('keydown', keydownHandler);
      }

    }
  }

  function a11yOpen() {
    if (!this.hasAttribute('aria-hidden')) return;

    this.inert = false;

    // inert will restore the previous state of aria-hidden (true) so we must
    // remove the aria-hidden attribute after inert has finished
    this.removeAttribute('aria-hidden');

    // we need to inert every subtree except for the one that contains this dialog
    // walk up the DOM tree and add inert to all children except for the child
    // that contains the dialog's tree. save each node we inerted so we don't have
    // to walk the tree again to uninert nodes
    this._inertedElements = [];
    this._uninertedElements = [];
    var el = this;

    do {

      // an element that is a child of a shadowroot will have a parentNode but not
      // a parentElement. a shadowroot element has neither but instead has a host
      var parent = el.parentNode || el.host;

      // if the dialogs subtree has already been inerted, then we need to uninert it
      if (parent.inert) {
        parent.inert = false;
        this._uninertedElements.push(parent);
      }

      for (var i = 0, child; child = parent.children[i]; i++) {

        // by only adding inert to elements that have not been inerted, we can
        // preserve a11y through stacking modals
        if (!(child === el || child.hasAttribute('data-no-inert') || child.inert)) {
          child.inert = true;
          this._inertedElements.push(child);
        }
      }

      el = parent;
    } while (el !== document.body);
  }

  function a11yClose () {
    if (this.hasAttribute('aria-hidden')) return;

    this.setAttribute('aria-hidden', true);

    // in Safari, removing the overflow style or uninerting nodes causes a
    // visual delay in any css animations so we have to wrap it in a set timeout
    // to get it off the current frame (50ms doesn't seem to be enough)
    setTimeout(function () {
      document.body.style.overflow = null;

      // uninert all nodes
      this._inertedElements.forEach(function (node) {
        node.inert = false;
      });
      this._uninertedElements.forEach(function (node) {
        node.inert = true;
      });
      this._inertedElements = null;
      this._uninertedElements = null;
    }.bind(this), 100);
  }

  if('customElements' in window){
    customElements.define('fs-modal-dialog', FSModalDialog);
  } else {
    document.registerElement('fs-modal-dialog', {prototype: Object.create(FSModalDialog.prototype)});
  }
})();
</script>
