<!-- <script src="../webcomponentsjs/webcomponents-lite.js"></script> -->
<link rel="import" href="../fs-globals/fs-globals.html">
<link rel="import" href="../fs-dialog/fs-dialog-base.html">
<script src="../fs-dialog/fs-dialog-positioning-obj.js"></script>

<style data-fs-anchored-dialog>

  fs-anchored-dialog {
    position: absolute;
  }

  fs-anchored-dialog .fs-dialog-pointer {
    border: 16px solid transparent;
    content: '';
    height: 0;
    overflow: visible;
    position: absolute;
    width: 0;
    /*box-shadow: 0px 0px 4px 0px rgba(0,0,0,0.35), 0px 3px 2px 0px rgba(0,0,0,0.18);*/
    /*background-color: #fff;
    height: 22.627px;
    width: 22.627px;
    transform: rotate(45deg);*/
  }
  fs-anchored-dialog[pointer-direction="up"] .fs-dialog-pointer {
    left: calc(50% - 16px);
    top: -16px;
    border-bottom-color: #FFF;
    border-top-width: 0;
  }
  fs-anchored-dialog[pointer-direction="down"] .fs-dialog-pointer {
    left: calc(50% - 16px);
    bottom: -16px;
    border-top-color: #FFF;
    border-bottom-width: 0;
  }
  fs-anchored-dialog[pointer-direction="left"] .fs-dialog-pointer {
    left: -16px;
    top: calc(50% - 16px);
    border-right-color: #FFF;
    border-left-width: 0;
  }
  fs-anchored-dialog[pointer-direction="right"] .fs-dialog-pointer {
    right: -16px;
    top: calc(50% - 16px);
    border-left-color: #FFF;
    border-right-width: 0;
  }
  fs-anchored-dialog[no-pointer] .fs-dialog-pointer {
    visibility: hidden;
    display: none;
  }

  @media screen and (max-width: 480px) {

    fs-anchored-dialog:not([fullscreen-on-mobile="false"]) .fs-dialog-pointer {
      visibility: hidden;
      display: none;
    }
  }

</style>

<template id="fs-anchored-dialog-template">
  <div class="fs-dialog-pointer"></div>
</template>

<script>
(function() {
  var doc = (document._currentScript || document.currentScript).ownerDocument;
  var template = doc.querySelector('#fs-anchored-dialog-template');
  var positioningObj = FS.dialog.service.positioningObj;

  var LEFT = 'left';
  var RIGHT = 'right';
  var UP = 'up';
  var DOWN = 'down';
  var CENTER = 'center';
  var BOTTOM = 'bottom';
  var TOP = 'top';
  var POINTER_DIRECTION = 'pointer-direction';
  var POINTER_BASE = 32;
  var POINTER_ALTITUDE = 16;
  var PADDING = 15;
  var positionObjDefaults = {
    preferredPointerDirection: ''
  };

  var fsAnchoredDialog = Object.create(FS.dialog.baseDialogComponent);

  /**
   * Initialize the popover, add events, and accessibility features. Should only change
   * the DOM on attached callback otherwise it breaks Polymer bindings.
   */
  fsAnchoredDialog.attachedCallback = function () {
    fsAnchoredDialog.baseDialog.appendStyles(doc, 'style[data-fs-anchored-dialog]', this);

    var clone = document.importNode(template.content, true);
    this.appendChild(clone);

    var doNotDismissOnBlur = this.getAttribute('persistent')
    // set the type="modeless" for the a11y enhancer
    this.setAttribute('type', 'modeless');
    if (doNotDismissOnBlur) {
      this.removeAttribute('dismiss-on-blur');
    } else {
      this.setAttribute('dismiss-on-blur', '');
    }

    fsAnchoredDialog.baseDialog.attachedCallback.bind(this)(openAnchoredFunction, closeAnchoredFunction)

    function openAnchoredFunction(positionObj) {
      /* positionObj: {
        preferredPointerDirection: [LEFT, RIGHT, UP, DOWN],
        forcedPointerDirection: LEFT,
        preferredAttachDirection: []
        forcedAttachDirection: BELOW,
        attachToElement: document.querySelector('button'),
        TODO: noPointer: false,
        TODO: forceAlignWithElementDirection: LEFT | RIGHT | CENTER | TOP | BOTTOM, //Only use with noPointer === true
        TODO: attachToCoordinates,
        TODO: closeOnScroll: false,
      } */
      // we get the last one in the array because that should be the one that belongs to this dialog in case there are nested popovers
      var pointerElement = this.querySelectorAll('.fs-dialog-pointer')[this.querySelectorAll('.fs-dialog-pointer').length - 1];
      // reset styles on elements
      pointerElement.style.top = '';
      pointerElement.style.left = '';
      this.style.top = '';
      this.style.left = '';

      var noPointer = this.getAttribute('no-pointer');

      // these will always be drop down type menus as far as the use cases we have currently go
      if (noPointer !== undefined && noPointer !== null) {
        var attachToElementDirection = positionObj.attachDirection || this.getAttribute('attach-direction') || '';
        var alignmentDirection = positionObj.alignment || this.getAttribute('alignment') || '';
        // get the global coordinates of the src rect
        var srcRect = positioningObj.fsLocalToGlobal(positionObj.attachToElement);
        var dialogWidth = this.offsetWidth;
        var dialogHeight = this.offsetHeight;
        var topOffset = getTopOffset(this.offsetParent);
        var dialogTop, dialogLeft, dialogRect;

        switch(attachToElementDirection) {
          case BOTTOM:
          case TOP:
          default:
            switch (alignmentDirection) {
              case CENTER:
                dialogLeft = srcRect.left - dialogWidth/2 + srcRect.width/2;
                break;
              case RIGHT:
                dialogLeft = srcRect.left + srcRect.width - dialogWidth;
                break;
              case LEFT:
              default:
                dialogLeft = srcRect.left
                break;
            }
            break;
          case LEFT:
          case RIGHT:
            switch (alignmentDirection) {
              case CENTER:
                dialogTop = srcRect.top - dialogHeight/2 + srcRect.height/2 + topOffset;
                break;
              case TOP:
              default:
                dialogTop = srcRect.top + topOffset;
                break;
              case BOTTOM:
                dialogTop = srcRect.bottom + topOffset - dialogHeight;
                break;
            }
            break;
        }

        switch(attachToElementDirection) {
          case BOTTOM:
          default:
            dialogTop = srcRect.bottom + getTopOffset(this.offsetParent);
            break;
          case TOP:
            dialogTop = srcRect.top + getTopOffset(this.offsetParent) - dialogHeight;
            break;
          case LEFT:
            dialogLeft = srcRect.left - dialogWidth;
            break;
          case RIGHT:
            dialogLeft = srcRect.right;
            break;
        }

        dialogRect = new positioningObj.fsRect(dialogLeft, dialogTop, dialogWidth, dialogHeight)
        dialogRect = positioningObj.fsGlobalToLocal(this.offsetParent, dialogRect);
        positionDialogWithinDom(this, pointerElement, dialogRect, {left: 0, top: 0}, UP);
      } else if (positionObj.forcedPointerDirection) {
        var newRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, positionObj.forcedPointerDirection)
        positionDialogWithinDom(this, pointerElement, newRects.dialogRect, newRects.pointerRect, positionObj.forcedPointerDirection)
      } else {
        //auto-position
        var prefOrder = [LEFT, RIGHT, UP, DOWN]
        // TODO: take a user passed preferred order
        var best = 0;
        var pos = prefOrder[0];
        var containingRect = positioningObj.fsGetWindowRect();
        var newRects;
        var leftRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, LEFT);
        var rightRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, RIGHT);
        var upRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, UP);
        var downRects = getRectsWithForcedDirection.bind(this)(positionObj.attachToElement, this, pointerElement, DOWN);

        var scores = {};
        scores.left = positioningObj.fsCalculatePercentageVisible(leftRects.dialogRect, containingRect);
        scores.right = positioningObj.fsCalculatePercentageVisible(rightRects.dialogRect, containingRect);
        scores.up = positioningObj.fsCalculatePercentageVisible(upRects.dialogRect, containingRect);
        scores.down = positioningObj.fsCalculatePercentageVisible(downRects.dialogRect, containingRect);

        prefOrder.every(function(tempPos) {
          if(best < scores[tempPos]) {
            pos = tempPos;
            best = scores[tempPos];
          }
          return true;
        });

        switch(pos) {
          case LEFT:
            newRects = leftRects;
            break;
          case RIGHT:
            newRects = rightRects;
            break;
          case UP:
            newRects = upRects;
            break;
          case DOWN:
            newRects = downRects;
            break;
        }
        positionDialogWithinDom(this, pointerElement, newRects.dialogRect, newRects.pointerRect, pos)
      }
    }

    function closeAnchoredFunction() {
      return;
    }

    function positionDialogWithinDom(dialogElement, pointerElement, newDialogRect, newPointerRect, direction) {
      // set the pointer-direction attribute
      dialogElement.setAttribute(POINTER_DIRECTION, direction);
      // position in the dom the dialog
      dialogElement.style.left = newDialogRect.left + 'px';
      dialogElement.style.top = newDialogRect.top + 'px';
      // position in the dom the pointer
      if (direction === LEFT || direction === RIGHT) {
        // the pointer element isn't relative to the dialog (its offset parent), it is realtive to the
        // dialog's offset parent. So, we have to subtract ou the dialog's top and left to get the top
        // and left of the pointer relative to the dialog.
        pointerElement.style.top = (newPointerRect.top - newDialogRect.top) + 'px';
      } else {
        pointerElement.style.left = (newPointerRect.left - newDialogRect.left) + 'px';
      }
    }

    function getTopOffset(dialogElementOffsetParent) {
      var topOffset = 0;
      if (dialogElementOffsetParent === document.body && window.getComputedStyle(document.body).position) {
        var bodyRect = document.body.getBoundingClientRect();
        topOffset = bodyRect.top + window.pageYOffset;
      }
      return topOffset;
    }

    function getRectsWithForcedDirection (sourceElement, dialogElement, pointerElement, direction) {

      var windowRect = positioningObj.fsGetWindowRect();
      var globalSrcRect = positioningObj.fsLocalToGlobal(sourceElement);
      var dialogElementOffsetParent = dialogElement.offsetParent || document.body;
      var srcRect = positioningObj.fsLocalToLocal(sourceElement, dialogElementOffsetParent);
      var pointerRect = positioningObj.fsLocalToLocal(pointerElement, dialogElementOffsetParent);
      var dialogRect = positioningObj.fsLocalToLocal(dialogElement, dialogElementOffsetParent);
      var dialogHeight = dialogElement.offsetHeight;
      var dialogWidth = dialogElement.offsetWidth;
      var topOffset = getTopOffset();

      // there's some weird stuff with positioning if the body is the dialog's offset parent
      if (dialogElementOffsetParent === document.body) {
        var bodyPosition = window.getComputedStyle(document.body).position
        var bodyRect = document.body.getBoundingClientRect();
        var leftOffset = bodyRect.left + window.pageXOffset;
        if (bodyPosition === 'static') {
          // sometimes the margins will mess up the getBoundingClientRect function on the
          // body, but if it's statically positioned, then we can just use the global rect
          srcRect = globalSrcRect;
          dialogRect = positioningObj.fsLocalToGlobal(dialogElement);
          // TODO: maybe you won't have to use the stupid topOffset on the pointerRect later if you globalize it here
          // for some reason the offset only applies on the left/right dialogs. Again, not sure why.
          if (direction === LEFT || direction === RIGHT) {
            srcRect.top = srcRect.top + topOffset;
            dialogRect.top = dialogRect.top + topOffset;
          // TODO: maybe you won't have to use the stupid topOffset on the pointerRect later if you globalize it here
          }
        } else {
          // the left for some reason doesn't always get calculated correctly if the body
          // is not positioned statically - this gives us the relative position
          srcRect.left = srcRect.left - leftOffset;
          dialogRect.left = dialogRect.left - leftOffset;
          // TODO: maybe you won't have to use the stupid topOffset on the pointerRect later if you globalize it here
        }
      }

      var srcHorizontalCenter = srcRect.left+(srcRect.width/2);
      var srcVerticalCenter = srcRect.top+(srcRect.height/2);
      var dialogTop = srcVerticalCenter-(dialogHeight/2);
      var dialogLeft = srcHorizontalCenter-(dialogWidth/2);
      var globalSrcHorizontalCenter = globalSrcRect.left+(globalSrcRect.width/2);
      var globalSrcVerticalCenter = globalSrcRect.top+(globalSrcRect.height/2);
      var globalDialogTop = globalSrcVerticalCenter-(dialogHeight/2);
      var globalDialogBottom = globalSrcVerticalCenter+(dialogHeight/2);
      var globalDialogRight = globalSrcHorizontalCenter+(dialogWidth/2);
      var globalDialogLeft = globalSrcHorizontalCenter-(dialogWidth/2);
      var xOffset = calculateXOffset.bind(this)();
      var yOffset = calculateYOffset.bind(this)();
      return positionDialog(xOffset, yOffset);

      function calculateXOffset() {
        var xOffset = 0;
        switch(direction){
          case UP:
          case DOWN:
            if (globalDialogRight > windowRect.right) {
              xOffset = -(globalDialogRight - windowRect.right);
            } else if (globalDialogLeft < windowRect.left) {
              xOffset = Math.abs(globalDialogLeft) + windowRect.left;
            }
            break;
          case LEFT:
            xOffset += POINTER_ALTITUDE;
            break;
          case RIGHT:
            xOffset -= POINTER_ALTITUDE;
            xOffset -= srcRect.width;
            xOffset -= dialogWidth;
            break;
        }
        return xOffset;
      }

      function calculateYOffset() {
        var yOffset = 0;
        switch(direction) {
          case UP:
            yOffset += POINTER_ALTITUDE;
            break;
          case DOWN:
            yOffset -= POINTER_ALTITUDE;
            yOffset -= globalSrcRect.height;
            yOffset -= dialogHeight;
            break;
          case LEFT:
          case RIGHT:
            if (globalDialogBottom > windowRect.bottom) {
              yOffset = -(globalDialogBottom - windowRect.bottom);
            } else if (globalDialogTop < windowRect.top) {
              yOffset = windowRect.top - globalDialogTop;
            }
            break;
        }
        return yOffset;
      }

      // TODO: rename
      function positionDialog(xOffset, yOffset) {
        var newDialogRectTop;
        var newDialogRectLeft;
        var newDialogRect;
        var newPointerRect = getNewPointerRect(pointerRect, srcRect, direction);
        switch(direction) {
          case UP:
          case DOWN:
            newDialogRectTop = srcRect.top+srcRect.height+yOffset;
            newDialogRectLeft = dialogLeft+xOffset;
            newDialogRect = new positioningObj.fsRect(newDialogRectLeft, newDialogRectTop, dialogWidth, dialogHeight);
            if (newDialogRect.left > newPointerRect.left - PADDING) {
              newDialogRect.left = newPointerRect.left - PADDING;
            } else if (newDialogRect.right < newPointerRect.right + PADDING) {
              newDialogRect.left = newDialogRect.left + (newPointerRect.right + PADDING - newDialogRect.right + PADDING);
            }
            break;
          case LEFT:
          case RIGHT:
            newDialogRectLeft = srcRect.left+srcRect.width+xOffset;
            newDialogRectTop = dialogTop+yOffset;
            newDialogRect = new positioningObj.fsRect(newDialogRectLeft, newDialogRectTop, dialogWidth, dialogHeight);
            if (newDialogRect.top > newPointerRect.top - PADDING) {
              newDialogRect.top = newPointerRect.top - PADDING;
            } else if (newDialogRect.bottom < newPointerRect.bottom + PADDING) {
              newDialogRect.top = newDialogRect.top + (newPointerRect.bottom + PADDING - newDialogRect.bottom);
            }
            break;
        }
        return {
          dialogRect: newDialogRect,
          pointerRect: newPointerRect
        }

        function getNewPointerRect(pointerRect, srcRect, direction) {
          var newPointerRectTop = pointerRect.top;
          var newPointerRectLeft = pointerRect.left;
          var newPointerRect;
          var pointerWidth;
          var pointerHeight;

          switch(direction) {
            case UP:
            case DOWN:
              newPointerRectLeft = srcRect.left + ((srcRect.width - POINTER_BASE)/2);
              pointerHeight = POINTER_ALTITUDE;
              pointerWidth = POINTER_BASE;
              break;
            case LEFT:
            case RIGHT:
              newPointerRectTop = srcRect.top+((srcRect.height - POINTER_BASE)/2) - topOffset;
              pointerHeight = POINTER_BASE;
              pointerWidth = POINTER_ALTITUDE;
              break;
          }
          return newPointerRect = new positioningObj.fsRect(newPointerRectLeft, newPointerRectTop, pointerWidth, pointerHeight);
        }
      }
    };

  };

  fsAnchoredDialog.attributeChangedCallback = fsAnchoredDialog.baseDialog.attributeChangedCallback;

  document.registerElement('fs-anchored-dialog', {prototype: fsAnchoredDialog});
})();
</script>
